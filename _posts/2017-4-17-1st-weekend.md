---
layout: post
title: 1주차
---

## 박수찬 : ~ 58 (1.3.5절)
### 1.데이터 저장구조와 특징

#### 1.1 테이블과 인덱스의 분리형

    - 관계형 데이터베이스 이전에선 저장한 데이터에서 특정 범위를 선별해 찾으려면 키의 도움을 받아야했음
    - 따라서 데이터 저장 역시 필연적으로 키에게 영향을 받았음
    - 만약 키와 데이터가 떨어져있더라도 키를 찾아갔을 때 데이터를 찾을 수 있다면? 저장 시 부담이 크게 감소
    - 대신 나중에 쉽게 찾을 수 있도록 기록해야하지만, 이는 여유있는 시간에!
    - 테이블과 인덱스가 별도로 분리되어있는 구조는 관계형 데이터베이스의 가장 일반적인 데이터 저장 형식.

#### 1.1.1 분리형 테이블의 구조

    - [그림1-1-2] 참고
    - 테이블스페이스 -> 논리적인 저장공간
    - 테이블스페이스를 용도별로 나눈 것이 세그먼트
    - 세그먼트에는 오브젝트가 들어올 수 있다.
    - 파티션이 발생한 테이블이나 인덱스는 각각의 파티션이 오브젝트가 됨
    - 개별 파티션이나 파티션되지 않는 테이블들은 반드시 하나의 테이블스페이스에만 존재
    - 즉, 테이블스페이스 내에서 상대적인 번호만 붙여도 하나의 오브젝트내에서 유일하게 식별이 가능
(ex : 경기도 성남시 분당구 삼평동 ‘629번지’ 로 플레이뮤지엄 주소 파악이 가능)
    - 집 주소와 비교하자면 인덱스의 모든 로우에 들어가는 ROWID가 바로 집 주소
    - ROWID는 테이블에 존재하는 것이 아닌, 인덱스에 존재.
    - ROWID는 Object No - Datafile No - Block No - Slot No 로 구성되어있다.
    - 블록이 아파트의 한 ‘가구’이고 슬롯이 ‘방 번호’라면, 블록 내에서는 아무리 이동해도 ROWID는 변하지 않는다.
(ex : 본인의 집에서 작은 방에서 큰 방으로 이동한다고 주소를 바꾸진 않는다)
    - 만약 다른 블록으로 로우가 이동하게 되었다면 ROWID는 변경하게 된다.
    - 과거의 ROWID로 접근 시, 새 ROWID로 이동하게끔 할 수 있지만 오버헤드 감수가 필요.
    - 체인과 비슷한 개념으로 보이겠지만 체인은 하나의 로우가 한 블록을 넘을 시 블록끼리 연결하여 저장하는 방법을 뜻함

#### 1.1.2 클러스터링 팩터

    - 분리형 테이블의 구조의 최대 특징은 데이터의 값에 전혀 무관하게 ‘임의의 위치’에 저장된다는 것
    - 얼마나 흩어져있냐에 따라 성능 차이가 발생할 수 있다.
    - 액세스 해두었던 블록에서 원하는 로우를 찾을 확률이 높다면, 물리적으로 액세스할 블록의 량은 분명 줄어듦
    - 인덱스의 컬럼값으로 정렬되어있는 인덱스 로우의 순서와 테이블에 저장되어있는 데이터 로우의 위치가 얼마나
비슷한 순서로 저장되어있냐 -> ‘클러스터링 팩터’
     - [그림1-1-3]을 보면 인덱스1은 7개의 로우를 액세스 했을 때 2개의 블록이지만 인덱스2는 3개 로우 액세스 시, 3개 블록 액세스
    - 크게 향상시킬 수 있는 방법은 주기적으로 테이블을 재생성하는 것

#### 1.1.3 분리형 테이블의 액세스 영향요소

**가) 넓은 범우의 액세스 처리에 대한 대처방안**

    - 소형 테이블 : 특별한 경우가 아리나면 별다른 조치를 취하지 않아도 됨.
    - 중형 테이블
    - 활용도에 따라 빈번한 액세스가 일어날 수 있다.
        - 액세스 형태를 선정하는 것이 제일 중요.
        - 모든 액세스 형태에 대해 맞출 순 없음을 인지할 것.
    - 대형 테이블
        - 첫 번째 형태 : 단순 저장형. 대표적으로 로그(Log). 신속한 저장 요구. 분리형이 적절하나 파티션 조치가 필요할 수 있음
        - 두 번째 형태 : ‘고객’ 테이블처럼 대량 데이터, 랜덤한 액세스가 일어나며, 액세스 형태는 다양하지 않은 경우. 분리형 구조가 적당. 파티션이나 클러스터링은 큰 효과 없음.
        - 세 번째 형태 : ‘매출’ 테이블처럼 대량의 데이터가 지속적으로 증가하며 다양한 형태의 액세스가 일어나는 경우. 파티션을 적용해야하며 테이블의 구조를 어떻게 결정할지가 제일 중요.

**나) 클러스터링 팩터 향상 전략**

    - 이미 저장된 데이터의 응집도를 높여주는 방법 -> 주기적인 테이블 재생성
    - 가장 고려해야할 요소는 새롭게 저장되는 데이터들이 유리한 형태로 저장되도록 하는 것.
    - 가장 자주 범위처리를 하는 컬럼(들)로 정렬하여 저장.
    - 약간의 부하가 증가하지만 힌트를 적용해서라도 그 인덱스를 경유하여 저장하도록 하는 것이 좋음.

#### 1.2 인덱스 일체형 테이블

    - 일반적인 B-tree 인덱스는 ‘인덱스 컬럼 + ROWID’로 구성. 따라서 인덱스 세그먼트에 액세스하고 이를 이용한 ROWID로 데이터 세그먼트 액세스를 하는 2번의 액세스가 발생.
    - 이게 모이면 오히려 부담
    - 테이블과 인덱스가 일체형이라면 테이블을 따로 액세스할 필요는 없다.

#### 1.2.1 분리형과 일체형의 비교 - 25페이지 표 참고

#### 1.2.2 일체형 테이블의 구조 및 특징

    - ROWID를 따로 갖고 있지 않다.
    - 넓은 범위의 스캔일 때 확실하게 효과가 나타남.
    - ROWID가 없기 때문에 추가적인 인덱스는 기본키를 사용하게 된다는 건 큰 단점이므로 액세스 형태가 다양하면 지양해야함.
    - 이 구조를 이용하지 않는 큰 이유는 로우 길이 변화에 따라 발생할 수 있는 오버플로우.

#### 1.2.3 논리적 ROWID와 물리적 주소

    - B-tree의 모든 노드는 2/3 정도만 키값들로 채워지므로 그 이상의 키값이 채워지면 키값들은 2개로 분할
    - 이로인해 일체형 테이블은 영구적인 물리적인 어드레스를 가질 수도 없음.
    - 결국 기본키만이 데이터를 구분할 수 있는 유일한 방법.
    - 일체형은 자신이 곧 테이블이므로 인덱스의 분할이 일어나면 로우의 이동에 따라 ROWID가 변할 수 있음.
    - 일체형의 효과적인 활용을 위해 ‘논리적 ROWID’라는 개념을 도입함. (29페이지 참고)
    - 구조는 유사하지만 키 분할에 의한 데이터 블록의 위치가 달라져도 변경되지 않음
    - 즉, 실제 찾는 로우가 없을 수도 있다.
    - 따라서 이 값은 ‘있을 가능성이 높은 주소’를 나타내므로 ‘PHYSICAL GUESS’라고 함.
    - 완벽하진 않지만 극히 일부를 제외하고는 유효하다면 기본키로 액세스를 하는 것보다 훨씬 유리함.
    - 물리적 위치정보를 사용하지 않는 경우
        1) 추가적인 인덱스를 액세스하여 기본키 정보를 얻는다.
        2) 기본키로 데이터 블록을 액세스를 한다.
    - 물리적 위치정보를 사용하는 경우
        1) 추가적인 인덱스를 액세스하여 물리적 위치정보를 참조한다.
        2) 참조한 물리적 위치정보를 이용하여 데이터 블록을 액세스한 후에 비교한다. 이 때 기본키 값이 같으면 물리적 위치정보가 유효한 것으로 간주하여 액세르를 종료한다.
        3) 유효하지 않다면 기본키로 액세스하여 데이터 블록을 가져온다.

#### 1.2.4 오버플로우 영역

    - 오버플로우 영역에 상대적으로 드물게 액세스 되는 것들을 옮기면 성능에 도움
    - 일체형 테이블 생성 시, 부여한 이동에 대한 임계치에 도달하면 ‘INCLUDING’ 절에서 지정한 컬럼 이후의 컬럼들은 모두 오버플로우 영역에 저장되므로 컬럼 지정 시, 순서를 잘 결정해야한다.
    - 일체형 구조의 본체는 인덱스 세그먼트에 저장되지만 오버플로우 영역은 테이블 세그먼트에 생성됨.
    - 이는 기존의 인덱스 / 테이블 형태와 비슷. 즉, 인덱스 영역에는 오버플로우 영역의 데이터를 찾기 위한 ROWID를 갖는다.

#### 1.2.5 일체형 테이블의 생성

    - 33페이지 참고
    - 일체형에서는 사용자가 체인을 결정할 수 있음 -> 액세스 성능이 달라짐
    - 어떤 모양으로 체인이 되었는지가 중요
    - 현재 및 향후 액세스 패턴을 분석하여 인덱스/오버플로우 영역을 나누자. 그게 힘들다면 일체형 선택은 하지말 것.

#### 1.3 클러스터링 테이블

    - 분리형은 대량의 데이터를 범위처리해야하는 경우 많은 랜덤을 발생시키는 부담
    - 일체형은 특정한 액세스에서는 랜덤이 줄어들지만 다양한 형태에서 부담
    - 클러스터링을 써보자.

#### 1.3.1 클러스터링 테이블의 개념

    - 클러스터 역시 테이블이나 인덱스처럼 저장공간을 가지고 있는 하나의 오브젝트
    - 멀리 떨어져 있는 공장(Table) 간에 매우 빈번하게 재료가 공급(Join)되어야한다면 두 공장을 인접한 곳에 배치(같은 클러스터 내에 생성)하여 콘베이어 벨트(Cluster Key)를 설치한다면 연결(Join)효율이 엄청남 -> ‘다중 테이블 클러스터링’
    - 창고(Table)에 수많은 부품(Row)들이 무질서하게 되어있다면? 이를 섹터(Secter, Cluster)로 나누어 동일한 유형의 부품(동일한 Cluster Key를 갖는 Row)로 보관하자. -> ‘단일 테이블 클러스터링’
    - 클러스터에 데이터를 저장하기 위해선 테이블 생성 뿐만 아니라 클러스터 인덱스도 같이 생성되어야함.
    - 클러스터는 클러스터링할 컬럼으로 생성된 클러스터 인덱스를 가짐.
    - 일반 인덱스는 테이블의 ‘로우’마다 하나씩의 인덱스 로우가 있지만…
    - 클러스터 인덱스는 클러스터링 ‘컬럼의 값’마다 하나씩의 인덱스 로우를 가짐.

#### 1.3.2 단일테이블 클러스터링

    - [39페이지 참고]
    - 클러스터링 테이블의 각 로우 헤더에 클러스터키 ID를 가지고 있으므로 같은 ID를 가진 로우들을 스캔 함으로써 우리가 원하는 집합 얻을 수 있음.
    - 하나의 클러스터 인덱스로 여러 개의 로우를 스캔방식으로 액세스 가능!
    - 클러스터키 값은 ‘단 한번만’ 저장함. 클러스터키 값 수정 시 다른 위치로 이동해야하는데 이는 ROWID의 변경을 의미하고 다른 일반 인덱스에 문제를 일으킨다.
    - 따라서 수정 시엔 최초 로우 위치에 '이주한 ROWID를 남기고' 본체는 모두 이동시킴.
    - 클러스터링 테이블은 일반 테이블의 개념이 한 단계 씩 높아졌다 생각하면 편함
        - 단위 클러스터 : 일반 테이블의 로우
        - 단위 클러스터 내의 로우 : 일반 테이블의 컬럼
        - 일반 테이블에서 로우마다 인덱스가 하나씩 존재 : 단위 클러스터마다 하나씩 인덱스  로우가 존재
        - ROWID : 클러스터키ID
    - 하지만 검색을 제외한 모든 경우에는 추가적인 부하를 발생시킴. (정해진 위치에 저장하니까)

#### 1.3.3 다중테이블 클러스터링

    - [43페이지 참고]
    - 단위 클러스터에 두 개 이상의 테이블을 함께 저장하는 것.
    - 블록헤더에 클러스터키 정보를 가지고 있으므로 단위 클러스터에서는 클러스터키 값을 가질 필요는 없다.
    - 조인할 대상이 동일 클러스터 내에 있다면 연결을 위한 추가적인 액세스를 하지 않으므로 매우 효율적인 JOIN이 가능.
    - 하지만 실전에선 아주 특별한 경우에만 사용
    - 이유는 각 테이블의 유연성이 훼손될 수 있기 때문.

#### 1.3.4 클러스터링 테이블의 비용

    - 해결해야할 액세스 형태, 보다 적은 비용이 드는 인덱스로 해결할 수 있는 방안 강구, 역할 중복으로 인한 투자의 낭비 등을 전부 고려해야함
    - INSERT 시 부하
        - 클러스터링 테이블은 각 로우들이 가진 클러스터키 값에 따라 저장위치가 다르다.
        - 즉, 일반 테이블이 '한 블록’에 100개의 로우를 저장할 수 있지만 클러스터링 테이블은 '100개의 블록’에 저장될 수 있다.
        - 부하를 간단하게 테스트 하는 방법은 ‘INSERT INTO… SELECT…WHERE ROWNUM <=100’ 과 같은 형태로 증가시키면서 수행속도를 확인하는 것.
        - 기존 인덱스를 그대로 두고 클러스터링만 추가적으로 활용한다면 부담은 늘어나겠지…만!
        - 클러스터링 도입 자체가 인덱스 개수를 감소하게 되므로 전체 비용은 크게 늘어나지 않게 될 것.
    - UPDATE 시 부하
        - 클러스터키 컬럼값이 변경된다는 건 다른 단위 클러스터로 ‘이동’한다는 것.
        - 앞서 이와 같은 경우에는 원래 위치에 이주해 간 위치정보를 남겨둔다 설명했음
        - 문제는 클러스터링 팩터가 나빠질 수 있다.
        - 이유는 동일한 클러스터키 값을 가진 로우가 여러 블록에 흩어지면서 원래의 목적이 희석될 수 있기 때문.
        - 따라서 수정이 빈번하게 발생하는 컬럼은 클러스터키 컬럼으로 지정하지 않는 것이 좋다.
    - DELETE 시 부하
        - 클러스터링 테이블의 모든 로우를 삭제하더라도 클러스터링 인덱스는 그대로 존재 하므로 오히려 부하는 감소
        - 하지만 DROP은 문제.
        - 일반 테이블의 삭제는 자료사전(Data Dictionary)의 정보를 삭제시키고 할당된 저장공간을 해제시키기만 하므로 매우 빠름.
        - 클러스터링 테이블 입장에선 단위 클러스터가 레코드, 로우는 컬럼이므로 테이블 DROP은 클러스터 입장에선 DELETE를 하게됨.
        - 따라서 불필요하게 된 과거의 데이터는 테이블 삭제보단 클러스터를 삭제하는 것이 좋다.

#### 1.3.5 해쉬 클러스터링

    - 일종의 인덱스를 대신하는 개념으로 볼 수 있음.
    - 우리가 원하는 값을 ‘찾아간다’라는 입장은 일종의 인덱스 개념.
    - 해쉬 클러스터링은 우리가 정의한 해쉬함수를 경유하여 어떤 값이 저장된 위치를 찾을 수 있도록 저장하는 기법.
    
**가) 해쉬 클러스터링의 특징**

        - SIZE, HASHKEYS, HASH IS 파라메터는 변경 불가능
        - 액세스는 '='로만.
        - 클러스터가 생성되면서 저장공간이 미리 할당됨.
        - 지정된 단위 클러스터보다 많은 로우가 들어오면 오버플로우 영역에 저장됨.
        - 컬럼의 값이 고르게 분포되어 있지 않으면 해쉬키 값의 충돌이 발생.
        - 인덱스를 경유하지 않고 해쉬함수로 계산된 값으로 직접 테이블을 액세스하므로 인덱스 보다 효율적인 액세스를 할수 있음.
        
**나) 해쉬 클러스터링의 활용 범위**

        - 지속적으로 대량의 데이터가 증가하는 테이블엔 적용하지 않는 것이 좋음
        - 검색 조건을 ‘=‘로만 사용해야한다는 것은 해쉬 클러스터의 활용을 크게 낮추는 특성
        - 해쉬키 값의 충돌이 발생하는 원인 역시 활용 범위를 제한
        - 따라서 각종 코드를 관리하는 소형 테이블이나 우편번호, 시스템 사용자 정보 관리 테이블에서 활용 가능.
        - 대량의 데이터를 일정량의 해쉬 클러스터에 저장시켜야한다면 해쉬 파티션을 사용하자.
        
**다) 해쉬 클러스터의 정의**

        - [56페이지 참고]
        - 단일테이블 해쉬 클러스터
        - 인덱스 클러스터에서 설명한 단일테이블 클러스터와 유사.
## 김민성 : 59 ~ 118 (3.1.2절)
