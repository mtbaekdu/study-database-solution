---
layout: post
title: 1주차
---

## 박수찬 : ~ 58 (1.3.5절)
### 1.데이터 저장구조와 특징

#### 1.1 테이블과 인덱스의 분리형

    - 관계형 데이터베이스 이전에선 저장한 데이터에서 특정 범위를 선별해 찾으려면 키의 도움을 받아야했음
    - 따라서 데이터 저장 역시 필연적으로 키에게 영향을 받았음
    - 만약 키와 데이터가 떨어져있더라도 키를 찾아갔을 때 데이터를 찾을 수 있다면? 저장 시 부담이 크게 감소
    - 대신 나중에 쉽게 찾을 수 있도록 기록해야하지만, 이는 여유있는 시간에!
    - 테이블과 인덱스가 별도로 분리되어있는 구조는 관계형 데이터베이스의 가장 일반적인 데이터 저장 형식.

#### 1.1.1 분리형 테이블의 구조

    - [그림1-1-2] 참고
    - 테이블스페이스 -> 논리적인 저장공간
    - 테이블스페이스를 용도별로 나눈 것이 세그먼트
    - 세그먼트에는 오브젝트가 들어올 수 있다.
    - 파티션이 발생한 테이블이나 인덱스는 각각의 파티션이 오브젝트가 됨
    - 개별 파티션이나 파티션되지 않는 테이블들은 반드시 하나의 테이블스페이스에만 존재
    - 즉, 테이블스페이스 내에서 상대적인 번호만 붙여도 하나의 오브젝트내에서 유일하게 식별이 가능
(ex : 경기도 성남시 분당구 삼평동 ‘629번지’ 로 플레이뮤지엄 주소 파악이 가능)
    - 집 주소와 비교하자면 인덱스의 모든 로우에 들어가는 ROWID가 바로 집 주소
    - ROWID는 테이블에 존재하는 것이 아닌, 인덱스에 존재.
    - ROWID는 Object No - Datafile No - Block No - Slot No 로 구성되어있다.
    - 블록이 아파트의 한 ‘가구’이고 슬롯이 ‘방 번호’라면, 블록 내에서는 아무리 이동해도 ROWID는 변하지 않는다.
(ex : 본인의 집에서 작은 방에서 큰 방으로 이동한다고 주소를 바꾸진 않는다)
    - 만약 다른 블록으로 로우가 이동하게 되었다면 ROWID는 변경하게 된다.
    - 과거의 ROWID로 접근 시, 새 ROWID로 이동하게끔 할 수 있지만 오버헤드 감수가 필요.
    - 체인과 비슷한 개념으로 보이겠지만 체인은 하나의 로우가 한 블록을 넘을 시 블록끼리 연결하여 저장하는 방법을 뜻함

#### 1.1.2 클러스터링 팩터

    - 분리형 테이블의 구조의 최대 특징은 데이터의 값에 전혀 무관하게 ‘임의의 위치’에 저장된다는 것
    - 얼마나 흩어져있냐에 따라 성능 차이가 발생할 수 있다.
    - 액세스 해두었던 블록에서 원하는 로우를 찾을 확률이 높다면, 물리적으로 액세스할 블록의 량은 분명 줄어듦
    - 인덱스의 컬럼값으로 정렬되어있는 인덱스 로우의 순서와 테이블에 저장되어있는 데이터 로우의 위치가 얼마나
비슷한 순서로 저장되어있냐 -> ‘클러스터링 팩터’
     - [그림1-1-3]을 보면 인덱스1은 7개의 로우를 액세스 했을 때 2개의 블록이지만 인덱스2는 3개 로우 액세스 시, 3개 블록 액세스
    - 크게 향상시킬 수 있는 방법은 주기적으로 테이블을 재생성하는 것

#### 1.1.3 분리형 테이블의 액세스 영향요소

**가) 넓은 범우의 액세스 처리에 대한 대처방안**

    - 소형 테이블 : 특별한 경우가 아리나면 별다른 조치를 취하지 않아도 됨.
    - 중형 테이블
    - 활용도에 따라 빈번한 액세스가 일어날 수 있다.
        - 액세스 형태를 선정하는 것이 제일 중요.
        - 모든 액세스 형태에 대해 맞출 순 없음을 인지할 것.
    - 대형 테이블
        - 첫 번째 형태 : 단순 저장형. 대표적으로 로그(Log). 신속한 저장 요구. 분리형이 적절하나 파티션 조치가 필요할 수 있음
        - 두 번째 형태 : ‘고객’ 테이블처럼 대량 데이터, 랜덤한 액세스가 일어나며, 액세스 형태는 다양하지 않은 경우. 분리형 구조가 적당. 파티션이나 클러스터링은 큰 효과 없음.
        - 세 번째 형태 : ‘매출’ 테이블처럼 대량의 데이터가 지속적으로 증가하며 다양한 형태의 액세스가 일어나는 경우. 파티션을 적용해야하며 테이블의 구조를 어떻게 결정할지가 제일 중요.

**나) 클러스터링 팩터 향상 전략**

    - 이미 저장된 데이터의 응집도를 높여주는 방법 -> 주기적인 테이블 재생성
    - 가장 고려해야할 요소는 새롭게 저장되는 데이터들이 유리한 형태로 저장되도록 하는 것.
    - 가장 자주 범위처리를 하는 컬럼(들)로 정렬하여 저장.
    - 약간의 부하가 증가하지만 힌트를 적용해서라도 그 인덱스를 경유하여 저장하도록 하는 것이 좋음.

#### 1.2 인덱스 일체형 테이블

    - 일반적인 B-tree 인덱스는 ‘인덱스 컬럼 + ROWID’로 구성. 따라서 인덱스 세그먼트에 액세스하고 이를 이용한 ROWID로 데이터 세그먼트 액세스를 하는 2번의 액세스가 발생.
    - 이게 모이면 오히려 부담
    - 테이블과 인덱스가 일체형이라면 테이블을 따로 액세스할 필요는 없다.

#### 1.2.1 분리형과 일체형의 비교 - 25페이지 표 참고

#### 1.2.2 일체형 테이블의 구조 및 특징

    - ROWID를 따로 갖고 있지 않다.
    - 넓은 범위의 스캔일 때 확실하게 효과가 나타남.
    - ROWID가 없기 때문에 추가적인 인덱스는 기본키를 사용하게 된다는 건 큰 단점이므로 액세스 형태가 다양하면 지양해야함.
    - 이 구조를 이용하지 않는 큰 이유는 로우 길이 변화에 따라 발생할 수 있는 오버플로우.

#### 1.2.3 논리적 ROWID와 물리적 주소

    - B-tree의 모든 노드는 2/3 정도만 키값들로 채워지므로 그 이상의 키값이 채워지면 키값들은 2개로 분할
    - 이로인해 일체형 테이블은 영구적인 물리적인 어드레스를 가질 수도 없음.
    - 결국 기본키만이 데이터를 구분할 수 있는 유일한 방법.
    - 일체형은 자신이 곧 테이블이므로 인덱스의 분할이 일어나면 로우의 이동에 따라 ROWID가 변할 수 있음.
    - 일체형의 효과적인 활용을 위해 ‘논리적 ROWID’라는 개념을 도입함. (29페이지 참고)
    - 구조는 유사하지만 키 분할에 의한 데이터 블록의 위치가 달라져도 변경되지 않음
    - 즉, 실제 찾는 로우가 없을 수도 있다.
    - 따라서 이 값은 ‘있을 가능성이 높은 주소’를 나타내므로 ‘PHYSICAL GUESS’라고 함.
    - 완벽하진 않지만 극히 일부를 제외하고는 유효하다면 기본키로 액세스를 하는 것보다 훨씬 유리함.
    - 물리적 위치정보를 사용하지 않는 경우
        1) 추가적인 인덱스를 액세스하여 기본키 정보를 얻는다.
        2) 기본키로 데이터 블록을 액세스를 한다.
    - 물리적 위치정보를 사용하는 경우
        1) 추가적인 인덱스를 액세스하여 물리적 위치정보를 참조한다.
        2) 참조한 물리적 위치정보를 이용하여 데이터 블록을 액세스한 후에 비교한다. 이 때 기본키 값이 같으면 물리적 위치정보가 유효한 것으로 간주하여 액세르를 종료한다.
        3) 유효하지 않다면 기본키로 액세스하여 데이터 블록을 가져온다.

#### 1.2.4 오버플로우 영역

    - 오버플로우 영역에 상대적으로 드물게 액세스 되는 것들을 옮기면 성능에 도움
    - 일체형 테이블 생성 시, 부여한 이동에 대한 임계치에 도달하면 ‘INCLUDING’ 절에서 지정한 컬럼 이후의 컬럼들은 모두 오버플로우 영역에 저장되므로 컬럼 지정 시, 순서를 잘 결정해야한다.
    - 일체형 구조의 본체는 인덱스 세그먼트에 저장되지만 오버플로우 영역은 테이블 세그먼트에 생성됨.
    - 이는 기존의 인덱스 / 테이블 형태와 비슷. 즉, 인덱스 영역에는 오버플로우 영역의 데이터를 찾기 위한 ROWID를 갖는다.

#### 1.2.5 일체형 테이블의 생성

    - 33페이지 참고
    - 일체형에서는 사용자가 체인을 결정할 수 있음 -> 액세스 성능이 달라짐
    - 어떤 모양으로 체인이 되었는지가 중요
    - 현재 및 향후 액세스 패턴을 분석하여 인덱스/오버플로우 영역을 나누자. 그게 힘들다면 일체형 선택은 하지말 것.

#### 1.3 클러스터링 테이블

    - 분리형은 대량의 데이터를 범위처리해야하는 경우 많은 랜덤을 발생시키는 부담
    - 일체형은 특정한 액세스에서는 랜덤이 줄어들지만 다양한 형태에서 부담
    - 클러스터링을 써보자.

#### 1.3.1 클러스터링 테이블의 개념

    - 클러스터 역시 테이블이나 인덱스처럼 저장공간을 가지고 있는 하나의 오브젝트
    - 멀리 떨어져 있는 공장(Table) 간에 매우 빈번하게 재료가 공급(Join)되어야한다면 두 공장을 인접한 곳에 배치(같은 클러스터 내에 생성)하여 콘베이어 벨트(Cluster Key)를 설치한다면 연결(Join)효율이 엄청남 -> ‘다중 테이블 클러스터링’
    - 창고(Table)에 수많은 부품(Row)들이 무질서하게 되어있다면? 이를 섹터(Secter, Cluster)로 나누어 동일한 유형의 부품(동일한 Cluster Key를 갖는 Row)로 보관하자. -> ‘단일 테이블 클러스터링’
    - 클러스터에 데이터를 저장하기 위해선 테이블 생성 뿐만 아니라 클러스터 인덱스도 같이 생성되어야함.
    - 클러스터는 클러스터링할 컬럼으로 생성된 클러스터 인덱스를 가짐.
    - 일반 인덱스는 테이블의 ‘로우’마다 하나씩의 인덱스 로우가 있지만…
    - 클러스터 인덱스는 클러스터링 ‘컬럼의 값’마다 하나씩의 인덱스 로우를 가짐.

#### 1.3.2 단일테이블 클러스터링

    - [39페이지 참고]
    - 클러스터링 테이블의 각 로우 헤더에 클러스터키 ID를 가지고 있으므로 같은 ID를 가진 로우들을 스캔 함으로써 우리가 원하는 집합 얻을 수 있음.
    - 하나의 클러스터 인덱스로 여러 개의 로우를 스캔방식으로 액세스 가능!
    - 클러스터키 값은 ‘단 한번만’ 저장함. 클러스터키 값 수정 시 다른 위치로 이동해야하는데 이는 ROWID의 변경을 의미하고 다른 일반 인덱스에 문제를 일으킨다.
    - 따라서 수정 시엔 최초 로우 위치에 '이주한 ROWID를 남기고' 본체는 모두 이동시킴.
    - 클러스터링 테이블은 일반 테이블의 개념이 한 단계 씩 높아졌다 생각하면 편함
        - 단위 클러스터 : 일반 테이블의 로우
        - 단위 클러스터 내의 로우 : 일반 테이블의 컬럼
        - 일반 테이블에서 로우마다 인덱스가 하나씩 존재 : 단위 클러스터마다 하나씩 인덱스  로우가 존재
        - ROWID : 클러스터키ID
    - 하지만 검색을 제외한 모든 경우에는 추가적인 부하를 발생시킴. (정해진 위치에 저장하니까)

#### 1.3.3 다중테이블 클러스터링

    - [43페이지 참고]
    - 단위 클러스터에 두 개 이상의 테이블을 함께 저장하는 것.
    - 블록헤더에 클러스터키 정보를 가지고 있으므로 단위 클러스터에서는 클러스터키 값을 가질 필요는 없다.
    - 조인할 대상이 동일 클러스터 내에 있다면 연결을 위한 추가적인 액세스를 하지 않으므로 매우 효율적인 JOIN이 가능.
    - 하지만 실전에선 아주 특별한 경우에만 사용
    - 이유는 각 테이블의 유연성이 훼손될 수 있기 때문.

#### 1.3.4 클러스터링 테이블의 비용

    - 해결해야할 액세스 형태, 보다 적은 비용이 드는 인덱스로 해결할 수 있는 방안 강구, 역할 중복으로 인한 투자의 낭비 등을 전부 고려해야함
    - INSERT 시 부하
        - 클러스터링 테이블은 각 로우들이 가진 클러스터키 값에 따라 저장위치가 다르다.
        - 즉, 일반 테이블이 '한 블록’에 100개의 로우를 저장할 수 있지만 클러스터링 테이블은 '100개의 블록’에 저장될 수 있다.
        - 부하를 간단하게 테스트 하는 방법은 ‘INSERT INTO… SELECT…WHERE ROWNUM <=100’ 과 같은 형태로 증가시키면서 수행속도를 확인하는 것.
        - 기존 인덱스를 그대로 두고 클러스터링만 추가적으로 활용한다면 부담은 늘어나겠지…만!
        - 클러스터링 도입 자체가 인덱스 개수를 감소하게 되므로 전체 비용은 크게 늘어나지 않게 될 것.
    - UPDATE 시 부하
        - 클러스터키 컬럼값이 변경된다는 건 다른 단위 클러스터로 ‘이동’한다는 것.
        - 앞서 이와 같은 경우에는 원래 위치에 이주해 간 위치정보를 남겨둔다 설명했음
        - 문제는 클러스터링 팩터가 나빠질 수 있다.
        - 이유는 동일한 클러스터키 값을 가진 로우가 여러 블록에 흩어지면서 원래의 목적이 희석될 수 있기 때문.
        - 따라서 수정이 빈번하게 발생하는 컬럼은 클러스터키 컬럼으로 지정하지 않는 것이 좋다.
    - DELETE 시 부하
        - 클러스터링 테이블의 모든 로우를 삭제하더라도 클러스터링 인덱스는 그대로 존재 하므로 오히려 부하는 감소
        - 하지만 DROP은 문제.
        - 일반 테이블의 삭제는 자료사전(Data Dictionary)의 정보를 삭제시키고 할당된 저장공간을 해제시키기만 하므로 매우 빠름.
        - 클러스터링 테이블 입장에선 단위 클러스터가 레코드, 로우는 컬럼이므로 테이블 DROP은 클러스터 입장에선 DELETE를 하게됨.
        - 따라서 불필요하게 된 과거의 데이터는 테이블 삭제보단 클러스터를 삭제하는 것이 좋다.

#### 1.3.5 해쉬 클러스터링

    - 일종의 인덱스를 대신하는 개념으로 볼 수 있음.
    - 우리가 원하는 값을 ‘찾아간다’라는 입장은 일종의 인덱스 개념.
    - 해쉬 클러스터링은 우리가 정의한 해쉬함수를 경유하여 어떤 값이 저장된 위치를 찾을 수 있도록 저장하는 기법.
    
**가) 해쉬 클러스터링의 특징**

        - SIZE, HASHKEYS, HASH IS 파라메터는 변경 불가능
        - 액세스는 '='로만.
        - 클러스터가 생성되면서 저장공간이 미리 할당됨.
        - 지정된 단위 클러스터보다 많은 로우가 들어오면 오버플로우 영역에 저장됨.
        - 컬럼의 값이 고르게 분포되어 있지 않으면 해쉬키 값의 충돌이 발생.
        - 인덱스를 경유하지 않고 해쉬함수로 계산된 값으로 직접 테이블을 액세스하므로 인덱스 보다 효율적인 액세스를 할수 있음.
        
**나) 해쉬 클러스터링의 활용 범위**

        - 지속적으로 대량의 데이터가 증가하는 테이블엔 적용하지 않는 것이 좋음
        - 검색 조건을 ‘=‘로만 사용해야한다는 것은 해쉬 클러스터의 활용을 크게 낮추는 특성
        - 해쉬키 값의 충돌이 발생하는 원인 역시 활용 범위를 제한
        - 따라서 각종 코드를 관리하는 소형 테이블이나 우편번호, 시스템 사용자 정보 관리 테이블에서 활용 가능.
        - 대량의 데이터를 일정량의 해쉬 클러스터에 저장시켜야한다면 해쉬 파티션을 사용하자.
        
**다) 해쉬 클러스터의 정의**

        - [56페이지 참고]
        - 단일테이블 해쉬 클러스터
        - 인덱스 클러스터에서 설명한 단일테이블 클러스터와 유사.
        

## 김민성 : 59 ~ 118 (3.1.2절)

### 제 2장 인덱스의 유형과 특징

* 키
  - 각종 무결성에 부합되는 논리적인 개념

* 인덱스
  - 전체 내용물 중에서 특정한 부분을 바로 찾을 수 있는 목차나 색인
  - DB내에 저장되는 물리적 구조체
  - 옵티마이져가 실행계획을 수립할때 최적의 경로를 찾도록 하는 '전략적 요소'라는 시각에서 접근하여야 한다.
  - SQL의 컬럼 액세스 정보 + (분포도, 카디널리티, 결합도, 중요도 등)을 함께 평가하여 인덱스를 구성

#### 2.1 B-Tree 인덱스

* B-Tree 인덱스는 관계형 데이터베이스에서 가장 일반적으로 사용되는 인덱스

#### 2.1.1 B-Tree 인덱스의 구조

- 테이블의 Row가 어떤 위치에 있든 동일한 처리방법과 속도로 접근할 수 있다. (Range Scan도 마찬가지)
  100건의 Row를 가진 테이블이나 100만건의 Row를 가진 테이블이나 한 건을 액세스하는 속도는 거의 같다.
- 클러스터링 팩터가 좋으면 매우 효율적인 액세스 가능
- 배열의 크기에 따라 효율성에 차이가 나타날 수 있으므로 가능하다면 적당한 배열의 크기를 지정하여 배열처리 유도
- 인덱스는 구성 컬럼들과 ROWIID로 정렬되어 있다. ROWID에는 물리적인 파일정보를 비롯하여 로우가 저장된 블록의 주소, 로우의 슬롯번호가 기록되어있다.

#### 2.1.2 B-Tree 인덱스의 조작

**가) 인덱스 생성**

- 가능하다면 최대한 인덱스 컬럼의 수를 줄인다.
- 가능하다면 큰 블록 사이즈(DB_BLOCK_SIZE)를 지정한다.
- PCTFREE를 가능하다면 최소로 정의한다.(0으로 지정해도 거의 문제 없다고 함)
- 키 압축을 활용. 유니크인덱스가 아닌 경우는 대부분 키값이 중복되어 있음.(특히 결합 인덱스)

**나) 인덱스 블록의 분할**

- 새로 입력되는 로우가 지금까지 발생한 다음부터 들어갈 수 있는 첨부 상태라면 분할을 하지 않고 들어갈 수 있다.<br>
'발생일자+ 항목'으로 인덱스가 구성되었다면 새로운 로우가 대량으로 삽입되더라도 분할은 발생하지 않는다.<br>
**이것은 곧 인덱스 컬럼의 순서에 따라 분할에 미치는 영향이 크게 다룰 수 있다는 것을 의미한다.**
- 중간에 삽입되는 경우는 저장공간이 크게 늘어날 수 있다. 이런 인덱스는 정기적으로 Rebuild 해줄 필요가 있다.

**다) 데이터의 삭제 및 갱신**

- 데이터를 삭제하면 테이블의 로우는 제거되지만 인덱스의 로우는 단지 삭제 Flag만 추가된다.<br>
  그 자리에 새로운 인덱스 로우가 추가되지 않는다면 저장공간의 낭비뿐만 아니라 스캔해야 할 블록이 증가하게 된다.
- Range Scan 할때는 삭제된 블록들도 액세스 될 수 있다.
- 인덱스 컬럼을 구성하고 있는 컬럼 값에 갱신이 발생하면 삭제 후 삽입이 발생.
이런 이유로 수정이 빈번하지 않은 컬럼을 인덱스로 사용하라고 권장하는 것.

<br>

> 인덱스는 삽입/삭제/갱신 시 언제나 저장공간을 과도하게 소비하고, 이에 따라 트리 구조의 깊이가 증가하게 된다. 그러므로 **데이터의 처리(DML)가 많이 수행되는 테이블은 인덱스를 정기적으로 재생성할 필요가 있다.**



**라) 인덱스를 경유한 검색**

- 69 ~ 70페이지 참고.

#### 2.1.3 리버스 키 인덱스(Reverse key index)

- 여기서의 리버스는 '역순'의 의미가 아니라 어떤 컬럼값이 바이트의 위치를 역전시키는 것을 말한다.<br>
12345 -> 54321<br>
<br>
이 개념이 가지는 특성은 원래의 인접된 값을 아주 멀리 분산시켜 버린다는 것에 있다.<br>
11112, 11113 -> 21111, 31111
- '='만 사용가능.(범위검색 X, 인덱스 Full Scan 가능)<br>
리버스 키 인덱스에서는 정렬이 크게 달라지므로, 다음 스캔을 했을때 우리가 원하는 범위의 값을 찾을수 없기 때문에 불가능.
- 실전에서 많이 사용하지는 않음

#### 2.2 비트맵 인덱스

- 컴퓨터에서 사용하는 최소 단위인 비트를 이용하여 컬럼값을 저장하고 이를 이용하여 ROWID를 자동으로 생성하는 인덱스
- 비트를 직접 관리하기 때문에 저장공간이 크게 감소하고 비트 별로 각종 연산을 수행함으로써 기존의 인덱스가 해결할 수 없었던 많은 문제를 해결하게 됨.
- 하지만, **여러 제약사항으로 인해 주로 데이터웨어하우스에서 활용됨.**
- 제약사항은 생성과 유지에 대한 비용이며, 검색 시에는 혁신적인 장점들을 가지고 있다.

#### 2.2.1 비트맵 인덱스의 탄생 배경(B-Tree 인덱스의 한계?)

- B-Tree인덱스에서는 실제 컬럼 값을 인덱스에도 보관하고 있어야 한다.<br>
  분명한 중복이며, 수행속도를 위해 여러 컬럼들로 구성된 결합 인덱스를 많이 생성하게 됨으로써 대용량 데이터를 관리할 때는 큰 부담이었다.
- B-Tree인덱스에서 가장 중요한 요소는 컬럼값의 분포도가 좁아야 한다는 것.<br>
  분포도가 넓은 경우는 오히려 전체 테이블을 모두 액세스하는 것보다 불리할 수도 있다.<br>
  이를 해결하기위해 여러 컬럼들을 결합하여 인덱스를 생성해야 했다.
- 결합인덱스는 조건을 사용하지 않는 컬럼이나 = 조건이 아닌 경우가 중간에 들어있으면 액세스 효율이 크게 저하되는 문제점을 안고 있었다.<br>
  이를 방지하기 위해 다양한 조합을 하도록 생성해야 하기 때문에 어떤 컬럼은 여러 개의 인덱스에 중복으로 구성되기도 하였다.
- 더욱 심각한 문제는 데이터 웨어하우스처럼 아주 카디널리티가 낮은 다수의 디맨전들이 사용자의 요구에 따라 매우 다양한 구조로 결합을 해야 하는 경우가 발생할 때이다.<br>
  이 경우 B-Tree인덱스로 해결하려면 엄청난 개수의 인덱스 필요.
- B-Tree인덱스에서는 NULL 값이나, 'NOT'을 사용한 부정형 조건, 복잡한 'OR'를 포함하고 있는 경우에는 인덱스로서의 가치를 발휘할 수 없었다.<br>
  이런 문제는 언제나 확실하게 처리 범위를 줄여줄 수 있는 일부의 컬럼들로만 인덱스를 구성하여 '처리조건을 주관'하고 나머지는 체크조건의 역할만 할수 있었다.
- 체크 조건의 역할은 테이블에서 액세스해야 할 량을 줄이는데는 기여하지 못한다.<br>
  이것은 우리가 얻는 결과가 소량임에도 불구하고 때로는 내부적으로 많은 범위를 액세스한 후 조건에 맞지 않는 것을 버리게 되었다는 것을 의미하므로 효율성에 아주 나쁜 영향을 미친다.
- 비트맵 인덱스는 위의 기술한 부분에 대한 탁월한 대안을 제시함.

#### 2.2.2 비트맵 인덱스의 구조와 특성

- 비트맵 인덱스는 루트 블록이나 브랜치 블록은 B-Tree인덱스와 같은 구조로 되어 있다. 리프 블록은 비트맵으로 구성됨.
- 비트를 저장할 때는 '선분 형태'로 저장을 하므로 일종의 압축 개념이 되며, **키 압축이 적용되어 저장공간이 매우 절약된다.**<br>
  또한 컬럼값을 직접 저장하는 것이 아니라 단지 해당 로우가 유효값을 가질 때 '1'이라는 비트가 저장될 뿐이다.
- 비트를 저장하는 방법에 의해 해당 비트를 액세스하여 이를 ROWID로 전환할 수 있으므로 B-Tree인덱스처럼 각 로우마다 ROWID를 가져가지도 않는다.
- 비트맵 인덱스는 B-Tree 인덱스처럼 분포도가 높지 않은 컬럼들을 굳이 결합할 필요가 없다.<br>
  각 비트맵 인덱스에서 추출한 결과를 이용해 비트맵 연산을 통해 처리할 수 있기 때문이다.<br>
  비트를 연산한 결과는 곧 조건을 머지한 결과이기 때문에 우리는 연산결과의 비트만 찾으면 조건이 만족된 로우를 찾을 수 있다.
NULL 값도 NULL이면 1이고, NULL이 아니면 0을 기록하면 되므로 B-Tree인덱스에서의 문제가 사라진다.
'NOT' 조건이 사용되더라도 비트값을 반대로 찾아내면 된다.
- 그러나, =이 아닌 LIKE, BETWEEN, ><, >=, <=가 사용되면 추출할 비트가 명확하지 않고, 대량이 나타날 수 있으므로 적합하지 않다.
- 빈번한 수정이 발생하는 컬럼은 인덱스의 크기가 크게 증가하고 블록레벨 잠금으로 인해 많은 부하가 발생될 수 있으므로 수정이 빈번하게 발생하는 OLTP 업무에는 적합하지 않는 경우가 많다.
- 카디널리티가 높은 컬럼에 대해서는 비트맵 인덱스의 장점이 사라진다.

#### 2.2.3 비트맵 인덱스의 액세스

- 비트맵 인덱스를 사용했을 때는 테이블을 액세스 하기 전에 인덱스만으로 모든 처리 범위를 직접적으로 줄이는데 사용하고, 그 결과로 테이블을 액세스한다.
- B-Tree인덱스를 사용한 경우는 인덱스로 테이블을 액세스한 다음 체크해서 버리게 되었기 때문에 비효율이 발생한다.<br>
 
**B-Tree 인덱스에서 체크 역할을 하는 조건이 많은 범위를 줄여주는 경우라면 큰 차이가 날 수 있다.**

#### 2.3 함수기반 인덱스

#### 2.3.1 함수기반 인덱스의 개념 및 구조

- 함수기반 인덱스는 테이블의 컬럼들을 가공한 논리적 컬럼을 인덱스로 생성한 것
- 가공된 논리적 컬럼들을 포함한 어떤 쿼리의 결과로 뷰를 생성해서 컬럼정보를 확인해보면 테이블과 다를 것이 없다.<br>
이러한 논리적 컬럼도 항목 명칭과 데이터타입, 길이, 컬럼값을 가지고 있기 때문.
- 옵티마이져는 쿼리를 파싱하면서 기술된 구문에서 함수기반 인덱스 사용이 가능한지를 판단한다.
- 액세스를 할때도 각 로우마다 일일이 어떤 연산을 할 필요가 없다.<br>
일반적인 컬럼으로 생성된 인덱스와 동일한 방법으로 비교한 값에 대해 인덱스를 검색하고 ROWID로 테이블을 액세스한다.
- 함수기반 인덱스는 함수나 수식으로 계산된 결과에 대해 B-Tree인덱스나 비트맵 인덱스를 생성할 수 있다.<br>
SUM, AVG 등의 그룹함수는 사용할 수 없다. 이 함수들은 테이블의 로우 단위가 아닌 새롭게 생성된 논리적 로우 단위로 적용되기 때문이다.

#### 2.3.2 함수기반 인덱스의 제약사항

- 84 ~ 85 페이지 참고
- 함수기반 인덱스에 사용자 지정함수를 적용한 경우 DBMS버전에 따라 중요한 차이가 있으므로 주의해서 적용해야 한다.
- 과거 버전에서는 사용자 함수를 재생성하면 'DISABLED' 상태가 되어 이를 복구하기 위해서는 인덱스를 재구축해야 한다고 했다.
- 최신버전에서는 사용가능상태로 나타나고 있다.
**이것은 과거의 값을 그대로 제공하는 방법이다.**
이러한 개념은 사용자 지정함수에 다른 테이블을 참조했을때도 동일하게 적용됨.
- 참조된 테이블들에서 데이터 입력/수정/삭제가 발생하면 함수기반 인덱스는 영향을 받게 된다.<br>
이들의 데이터에 변화가 생겼을때 함수기반 인덱스가 있는 테이블의 어떤 로우가 영향을 받을지 알수 없다.<br>
과거에는 참조 테이블의 데이터의 변경을 허용하지 않았다.<br>
현재는 참조하는 테이블의 데이터에 변화가 발생하면 함수기반 인덱스에 이미 저장된 과거의 데이터는 그대로 인정된다.
- 거의 데이터가 증가하지 않는 코드성 테이블들은 필요하다면 참조하여 보다 확장성 있도록 활용가능

#### 2.3.3 함수기반 인덱스의 활용

**가. 테이블의 설계상의 문제를 해결**

- 컬럼의 중간 부분의 검색

```sql
CREATE INDEX from_loc_idx on orders (SUBSTR(ship_id, 5, 3));
 
CREATE INDEX repair_ord_idx on orders (SUBSTR(ship_id, 3, 2), ord_date);
```

- 조인 연결고리 컬럼이 대응하지 않는 경우의 해결

```sql
CREATE INDEX group_cd_idx ON item_group (class1 || class2 || class3);
```

- 날짜 컬럼이 분할된 경우의 해결

```sql
CREATE INDEX sal_date_idx ON sales (sal_yyyy || sal_mm || sal_dd);
```

- 데이터 타입이 상이한 조인 컬럼

```sql
CREATE INDEX deptno_idx ON emp (TO_NUMBER(dept_no));
```

- 조인 컬럼이 경우에 따라 달라지는 경우의 조인

```sql
CREATE INDEX deptno_idx ON sales (CASE WHEN sal_type = 1 THEN sal_dept ELSE agent_no END);
```

- 부모 테이블의 컬럼과 결합한 인덱스 생성

```sql
CREATE or REPLACE FUNCTION get_deptno
( v_mov_order in number )
  RETURN varchar2 DETERMINISTIC IS
  RET_VAL varchar2(5);
BEGIN
  SELECT deptno into RET_VAL
    FROM movement
   WHERE mov_order = v_mov_order;
 
  RETURN RET_VAL
END get_deptno ;
 
 
CREATE INDEX dept_date_idx ON movement_trans (get_deptno(mov_order), mov_date);
```

**나. 오류 데이터의 검색문제를 해결**

- 대소문자나 공백이 혼재된 컬럼의 검색

```sql
CREATE INDEX ename_upper_ix ON employees (UPPER(REPLACE(ename, ' ')));
```

- NULL 값을 치환하여 검색

```sql
CREATE INDEX start_end_idx ON account_history (NVL(end_date, '99991231'), start_date);
```

- 접두사(Prefix)를 채워서 검색

```sql
CREATE INDEX call_number_idx ON call_data (DECODE(SUBSTR(call_number, 1, 3), '018', '', '016') || call_number);
```

**다. 가공처리 결과의 검색**

- 복잡한 계산 결과의 검색

```sql
CREATE INDEX order_amount_idx ON order_items (ITEM_CD, (order_price - nvl(order_discount, 0)) * order_count));
```

- 말일, 단가, 율의 검색

```sql
CREATE INDEX sal_amount_idx ON sales (LAST_DAY(sal_date), sal_amount);
 
CREATE INDEX price_idx ON sales (ROUND(sal_amount / sal_quantity));
```

- 기간, 컬럼 길이 검색

```sql
CREATE INDEX term_idx ON activities (expire_date - start_date);
 
CREATE INDEX source_length_idx ON print_media (text_length(source_text));
```

**라. 오브젝트 타입의 인덱스 검색**

```sql
CREATE INDEX volume_idx ON cube_tab x (x.volume());
```

**마. 배타적 관계의 인덱스 검색**

- 배타적 관계의 유일성 보장

```sql
CREATE UNIQUE INDEX official_id_idx ON customers (CASE WHEN cust_type = 1 THEN resident_id ELSE business_id END);
 
CREATE UNIQUE INDEX contract_idx ON insurance (CASE WHEN ins_type = 'A01' THEN customeer_id ELSE NULL END, CASE WHEN ins_type = 'A01' THEN ins_type ELSE NULL END);
```

- 배타적 관계의 결합 인덱스

```sql
CREATE INDEX order_delivery_idx1 ON order_delivery (order_dept, CASE WHEN ord_type = 1 THEN delivery_date ELSE shipping_date END, item_type);
```

### 제 3장 SQL의 실행계획

- 어떠한 SQL에도 최적의 실행계획이 수립될 수 있도록 각종 옵티마이징 팩터들을 전략적으로 구성

#### 3.1 SQL과 옵티마이져

- 관계형 데이터베이스에서는 SQL을 통해서만 데이터 처리 가능
- 옵티마이져는 SQL에 대해 구체적인 처리절차를 생성하고 실행가능한 수행모듈로 만든 후 실행 완료 후 결과 리턴
- 가장 최소량을 처리할 수 있도록 하는 것과 가장 싼 값으로 액세스 할수 있느냐가 가장 큰 영향 요소
- 처리해보기 전에 판단해야 하기 때문에 선택된 처리 방법이 항상 최적이라고는 할 수 없다.

#### 3.1.1 옵티마이져와 우리의 역할

- 가장 기본적인 옵티마이징 팩터는 인덱스의 구성 전략과 적절한 SQL 작성이다.

#### 3.1.2 옵티마이져의 형태

- 규칙기준 옵티마이져
인덱스, 클러스터링의 상태와 사용된 연산자의 형태에 따라 순위를 부여하고 가장 좋은 순위를 가지는 형태가 최적이라고 판단.<br>
치명적인 약점은 테이블의 크기, 인덱스 내의 컬럼값들의 분포도 등의 통계정보를 전혀 이용하지 않고 결정한다는 점
- 비용기준 옵티마이져
원가(cost)를 계산해보고 가장 최소의 비용이 드는 처리형태를 선택하는 것

#### 3.1.2.1 규칙기준 옵티마이져

- 114 페이지 규칙기준 옵티마이저 순위 참조
- 비용기준 옵티마이져가 자동이 강화되고 다양한 수동 조절기능이 추가됨으로써 거의 규칙기준 옵티마이져를 대체하려 하고 있다.

**가) 규칙기준 옵티마이져의 단점**

- 경우에 따라서 악성 실행계획이 나타날 확률이 높다

**나) 규칙기준 옵티마이져의 장점**

- 우리가 매우 전략적인 인덱스를 구성할 수 있다면 이 규칙의 보편 타당성이 매우 높아진다는 것
