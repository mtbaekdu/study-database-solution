---
layout: post
title: 2주차
---

## 이재홍 : 119 ~ 182 (3.1.5절)


# 비용기준 옵티마이져

  비용기준 옵티마이져는 관계형 데이터베이스가 추구하는 이상형

  미리 작성해둔 다양한 통계정보 참조(통계정보의 형태와 종류는 DBMS마다 상이)

  통계 정보엔 한계존재 -> 통계적 확률을 이용하기 때문에 오차 발생

  - 비용기준 옵티마이저 장점
    1. 현실을 감안한 최적화

       가장 중요한 정보는 분포도 -> 분포도를 정확히 알아내기 어려움 -> 옵티마이져의 한계

       이를 해결하기 위해 컬럼값의 범위별로 분포도를 보유, 분포도의 종류는 버킷에 따라 결정

       * 최대치와 최소치에 대한 균등 범위 분할(컬럼값이 적거나 분포도의 편차가 심하지 않을 경우): 넓이균형 히스토그램
       * 로우수를 버킷수로 나누어 분할(분포도의 차이가 심한 경우, 존재하지 않는 컬럼이 많을 경우): 높이균형 히스토그램

       일반적으로 분포도나 컬럼값의 편차가 심할 경우 판단에 문제가 많으므로 높이균형이 유리

       DBMS별 옵티마이져에 따라 방식이 정해져 있으며, 제공 프로시저를 활용하여 통계학적으로 적절한 수치의 자동 결정이 바람직

    2. 통계 정보의 관리를 통한 제어

       통계정보를 수집할 대상과 갱신 주기 등에 대한 적절전략을 수립

       DBMS가 제공하는 '테이블 모니터링 기능'을 사용하는 것이 가장 좋음 -> 모든 테이블이 다르므로 모두 다른 방법이필요

       * 통계정보의 잦은 갱신은 오버헤드가 발생하므로 주의 필요
       * 이미 최적의 경로를 안다면 힌트로 고정시키는 방법도 바람직

    3. 최악의 상황이 발생할 확률이 감소

       옵티마이저가 '이미 존재하는 논리 중' 최적의 경로를 찾아주기 때문

  - 비용기준 옵티마이져의 단점
    1. 실행계획 예측이 곤란
       
       인덱스/테이블을 재생성 또는 SQL을 재구성하거나 통계를 갱신하거나 갱신하지 않을 경우  실행계획이 유동적으로 변경됨

    2. 버전에 따른 변화

       최적화 기준의 변화로 실행계획이 변경되는 경우

       적절한 SQL을 구사하고 전략적인 옵타마이징 팩터 전략 수립 필요

    3. 실행계획 제어가 곤란

       쿼리를 필요에 따라 변경하거나 다양한 요소를 감안하여 실행계획을 수립하기 때문에 제어가 곤란

  - 옵티마이져의 발전방향
  
    발전해가는 방향은 비용기준임이 확실

    현재는 비용기준으로 통일되어 가고 있으므로 통계정보를 관리하는 많은 기능들이 필요

    단위 SQL보다는 테이블/인덱스 단위로 관리하는 등의 편의를 고려한 방법으로 높은 확률의 최적화를 

    유도해가는 것이 지향하는 방향이자 전략

  - 통계정보 관리를 위한 제언

    통계정보를 관리하는 것은 개발자보다는 설계자, 데이터 아키텍트(DA)의 레벨에서 하는 것이 바람직

    과거에는 I/O 즉, 물리적 처리량 만으로 통계정보를 산정

    최근에는 CPU 사용량 등도 추가하여 정확도 상승 

    -> 옵티마이져가 시스템 통계를 통해 보다 정확한 환경을 파악함으로서 환경에 맞는 수행환경을 제공하는 것이 가능

       예) OLTP/배치의 수행환경 구분 등

    통계정보의 수집엔 DBMS에서 제공하는 패키지를 이용하는 것을 권장

    데이터가 많은 경우 부하가 많을 수 있으므로 견본 데이터를 이용하여 수집하는 것도 가능(5%권장)

    병렬 처리도 가능

* 옵티마이져 목표의 선택

  옵티마이져가 수행하는 최적화는 시뮬레이션

  최적을 평가하는 기준에 따라 결과가 달라짐

  - 옵티마이져 모드의 종류

    1. 초기결과 최적화(FIRST_ROWS) - 마라톤과 비슷 1등이 최고! = CHOOSE 모드와 비슷

       비용기준과 경험적 방법을 혼합((비용 + 규칙기준)이었던 과거 버전과 양립하기 위함)

    2. 전체결과 최적화(ALL_ROWS) - 구보 낙오자 없이 -> 비용기준 최적화

    3. 커트라인(Cut line) 지정(FIRST_ROWS_n) -> 비용기준 최적화

    기본은 ALL_ROWS이지만 OLTP성 업무가 많은 현실에서는 FIRST_ROWS가 옳을 수도 있지 않을까?

  - 옵티마이져 모드의 결정기준

    1. OLTP성 업무의 경우 과거 CHOOSE 모드 있을 시 개발된 시스템은 FIRST_ROWS가 적합, 신규 버전일 경우 FIRST_ROWS_n이 적합

    2. OLAP형 Batch 처리 서비스는 ALL_ROWS가 유리

    옵티마이져 모드를 운영중에 변경하는 것은 매우 위험

    변경하기 위해서는 사전 준비를 통해 영향도를 줄여야 함

    실행계획을 고정하기 위한 2가지 방법

    * 초기 설정 파라메터에 과거 사용 버전을 지정
    * 실행계획 요약본을 작성하여 이를 참조하도록 하는 OUTLINE을 이용하는 방법

  - 규칙 기준을 비용기준으로 넘어가는 추세에서 기존 CHOOSE 모드에 대응되는 대책이 필요

    * 동적 표본화(Dynamic sampling): 소량의 표본을 동적으로 추출하여 통계정보로 활용, 이 기능을 적용하면 매번 수행되므로 빈번하게
      수행되는 경우에는 적용하면 안되나, 그 외의 경우에는 적용할 가치가 있음
    * 잘 동작하는 실행계획은 고정 할 필요가 있음

* 실행계획 고정화(Stability)

  - 아웃라인(OUTLINE)

    * 과거에 수행되었던 실행계획의 요약본을 저장하고 있다가 이것을 참조하여 실행계획을 수립하는 것
    * 아웃라인을 지나치게 사용하여 더 좋은 퍼포먼스 발휘의 가능성을 차단하지는 말아야 함.
    * 범용적/개별적으로 관리 가능하며 적용/금지 설정 및 강제 편집 등이 가능
    * 그룹으로 지정하여 관리 할 수 있으므로 상황별 적용이 가능(주간/야간 환경 변경, 서브시스템 등)
    * 옵티마이저 업그레이드 시 적용
      
       갑작스러운 기준 변화는 시스템에 큰 지장을 초래

       1. 규칙기준 -> 비용기준: 아웃라인 생성 후 통계수집 후 모드를 CHOOSE로 설정하여 일부에 아웃라인을 적용

       2. 버전업의 경우: 아웃라인을 생성 후 어플 테스트를 하여 문제가 있는 부분에 아웃라인을 적용

    * 문제 발생 SQL 들의 아웃라인 생성 후 그룹핑 하여 관리 하는 방법도 가능

* 옵티마이져의 한계

  - 완벽할 수 없는 통계정보로는 정확한 처리 범위를 예측 할 수 없음

  - 결합된 컬럼에 대해 일일이 분포도를 보유할 수 없음

  이에 대한 해결책으로 다양한 사용형태를 만족할 수 있는 종합적이고 전략적인 차원에서 적절한 인덱스나 클러스터링을 결정하고 수준높은 SQL을 구사

* 옵티마이져의 최적화 절차

  궁극적 목표는 사용자가 요구한 결과를 최소한의 자원으로 처리하는 방법을 찾는 것

  옵티마이져는 SQL문을 보유하고 있는 각종 스키마 객체(Index, Table 등)들에 대한 정보를 토대로 가장 효율적인 형태를 선택

  - SQL 실행 -> 데이터 베이스 딕셔너리를 이용하여 파싱 -> 파싱 절차를 토대로 적용가능 실행계획 선별 -> 힌트를 감안하여 실행계획 생성

  - 실행계획을 선별할 시 통계정보를 기반으로 선택

  - 가장 비용이 적은 실행계획 선택이 최선의 방법은 아님

* 옵티마이져의 구성

  - 질의 변환기

    보다 양호한 실행계획을 얻을 수 있도록 SQL의 모양을 변경하는 모듈

    1. 뷰병합

       뷰를 쿼리로 대체하여 뷰를 사용함으로 발생되는 불이익을 없앰

    2. 조건절 진입

       뷰병합이 어려운 경우 엑세스 쿼리의 조건절을 뷰쿼리 내부에 추가 하는 것

    3. 서브쿼리 비내포화

       서브쿼리를 가능할 경우 조인으로 변경

    4. 실체뷰(Meterialized view)의 쿼리 재생성

       확장된 뷰병합으로도 볼 수 있으며 가장 최적의 물리적 집합을 처리하도록 쿼리를 재생성

    5. OR 조건 전개

       OR 조건 연산자가 처리주관 조건의 역할을 한다면 여러 개의 단위 쿼리로 분기하여 UNION ALL로 연결, 비용을 계산 및 비교하여 전개여부 결정

    6. 사용자 정의 바인드 변수 엿보기(Peeking)

       조건절에 바인드 변수가 있을 때 최초로 수행된 변수로 실행계획 생성 후 공유

  - 비용 산정기

    옵티마이져는 비용산정을 위해 선택도, 카디널리티, 비용을 측정

    서로 연관되어 있으며 필요에 따라 관련된 예상치 생성

    1. 선택도(Selectivity)

       처리할 대상집합에서 해당 조건을 만족하는 로우가 차지하는 비율

       선택도를 판정하는 단위는 개별 컬럼 조건이 아닌 해당 엑세스를 주관하는 조건들의 모임

       각 통계정보를 활용하여 산정, 통계학적 연산을 통해 구하기 때문에 오차 존재

       히스토그램이 없다면 동적 표본을 이용해서 수립, 있다면 보다 정확한 근거를 가지고 계산될 수 있음

    2. 카디널리티(Cardinality)

       판정대상이 가진 결과건수(선택도 X 전체 로우수)

       같은 대상 집합에 대해서는 비율만으로 충분하나 조인의 순서, 방향 등을 결정하기 위해 절대량을 판단하기 위해 필요

    3. 비용(Cost)

       실행계획 상의 연산들을 수행할 때 소요되는 시간 비용을 상대적으로 계산한 예측치. 통계정보에 CPU, 메모리, I/O 고려

       옵티마이져의 가정들이 옳지만은 않기 때문에 잘못된 비용산정의 한계가 있으며 이를 보완하기 위해 다양한 힌트 및 초기화 파라메터가 추가되고 있음

  - 실행계획 생성기

    주어진 쿼리를 처리할 수 있는 적용 가능한 실행계획을 선별하고 비교검토를 거쳐 최소의 비용을 가진것을 선택하는 모듈

    * 부속 서브쿼리, 병합 불가능한 뷰들의 실행계획 생성(이 결과가 메인 쿼리에 절대적인 영향을 받기 때문에 먼저 생성)

      가장 깊은 곳에서 부터 우선적으로 최적화를 수행

    * 실행계획 생성기는 논리적으로 모든 비교평가를 하지는 않음

      각 상황별로 적절한 비교평가를 위해 적응적 탐색과 경험적 기법에 대한 초기치 선택(Cut off)하는 전략 사용

      1. 쿼리 수행에 예상되는 총 수행시간에 비해 최적화에 소요되는 시간이 일정비율을 넘지 않도록 탐색하는 전략

      2. 탐색도중 최적이라고 판단되면 탐색을 멈추는 전략

      추가로 자습적 기법을 통해 최적이거나 최소한 아주 좋은 것이라 판단되는 것들을 선별 후 선택

      힌트를 통해 보완을 해야 함

* 질의의 변환(162p)

* 이행성 규칙

  - A=B and B=C 이면 A=C

    -> 이를 통해 보다 유리한 조건을 적용할 가능성이 높아짐

    -> 비교하는 대상이 상수 수식이 아닌 경우 이행이 일어나지 않음

  - OR 조건 -> UNION ALL로 분기

    -> 기본적으로 여러 개로 분기된 경우 불필요한 엑세스가 있다면 이행 하지만 비용을 비교하여 취사선택함

  - 서브쿼리 -> 조인으로 변경

    -> 조인으로 변경하여 유리한 실행계획이 선택될 수 있도록 함
 
    -> 불가능한 경우 서브쿼리 부터 실행하거나 필터링, 해쉬/머지 조인으로 수행

* 뷰병합(169p)

  뷰와 인라인 뷰 등을 사용할 경우 엑세스 쿼리의 조건절이 실행계획을 선정하는데 영향을 못주지만 뷰병합을 통해 엑세스 쿼리의 조건절이 반영된 실행계획 생성

* 사용자 정의 바인드 변수의 엿보기(Peeking)

  바인드 변수가 사용된 SQL의 경우 최초에 수행되는 파싱이 일어날 때 사용된 변수에 대해 실행계획이 수립되는 것

  평균적인 분포도로판단한 경우 희석되는 변수들이 선택될 수 있으나 극단적인 편견이 발생될 수 있음

  이 경우 실행계획은 문제가 없으나 실제 수행에서는 문제가 발생할 수 있음

* 개발자의 역할

  SQL을 잘 활용하는 방법을 익혀두는 것이 필요

    


   


## 김창수 : 183 ~ 260 (3.2.3절)
